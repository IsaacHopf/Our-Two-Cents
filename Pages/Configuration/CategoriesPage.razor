@inject BudgetsRepository BudgetsRepository;
@inject CategoriesRepository CategoriesRepository
@inject FixedBudgetRepository FixedBudgetRepository;
@inject ISnackbar Snackbar
@using MudBlazor.Utilities

@page "/categories"

<MudText Typo="Typo.h4" Class="mb-6">Categories</MudText>

@if (_categories is null)
{
    <MudStack AlignItems="AlignItems.Center">
        <MudProgressCircular Color="Color.Default" Indeterminate="true" Class="mt-6" />
    </MudStack>
}
else
{
    <MudDataGrid T="Category" @ref="_gridRef" Items="@_categories" ReadOnly="false" EditMode="DataGridEditMode.Form" EditTrigger="DataGridEditTrigger.OnRowClick"
                 CommittedItemChanges="@CommittedItemChangesAsync" CanceledEditingItem="@CanceledEditingItem" EditDialogOptions="@_dialogOptions"
                 Hover="true" Bordered="true" Elevation="0" Class="w-100" Style="background-color: var(--mud-palette-primary-hover)">
        
        <ToolBarContent>
            <MudTooltip Text="Add Category" Delay="650">
                <MudIconButton OnClick="@SetNewEditingItemAsync" Icon="@Icons.Material.Rounded.Add" Color="Color.Primary" Variant="Variant.Filled" Class="toolbar-circle-button"/>
            </MudTooltip>
        </ToolBarContent>
        
        <Columns>
            <PropertyColumn Property="x => x.Id" Hidden/>
            <PropertyColumn Property="x => x.Name" Required>
                <EditTemplate>
                    <MudTextField Label="Name" @bind-Value="context.Item.Name" Variant="Variant.Filled"/>
                </EditTemplate>
            </PropertyColumn>
            <PropertyColumn Property="x => x.Color" Required>
                <CellTemplate>
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <div style="background-color: @context.Item.Color; width: 1rem; height: 1rem;" class="rounded"></div>
                        <span>@context.Item.Color</span>
                    </MudStack>
                </CellTemplate>
                <EditTemplate>
                    <MudText Typo="Typo.body1" Class="mt-2">Color</MudText>
                    <MudColorPicker Label="Color" @bind-Value="_currentColor" PickerVariant="PickerVariant.Static" ShowAlpha="false"/>
                </EditTemplate>
            </PropertyColumn>
            <TemplateColumn>
                <CellTemplate>
                    <MudIconButton OnClick="@(() => DeleteCategoryAsync(context.Item))" Icon="@Icons.Material.Rounded.Delete"
                                   Size="@Size.Small" Color="Color.Error"/>
                </CellTemplate>
            </TemplateColumn>
        </Columns>
    </MudDataGrid>
}

@code {
    private List<Category>? _categories;
    private MudDataGrid<Category>? _gridRef;
    private bool _addingCategory;
    private MudColor? _currentColor;

    private readonly DialogOptions _dialogOptions = new()
    {
        Position = DialogPosition.TopCenter,
        CloseOnEscapeKey = true,
        NoHeader = true
    };
    
    protected override async Task OnInitializedAsync()
    {
        _categories = await CategoriesRepository.ReadAsync();
    }

    private async Task SetNewEditingItemAsync()
    {
        _addingCategory = true;
        await _gridRef?.SetEditingItemAsync(new Category(string.Empty))!;
        StateHasChanged();
    }

    private async Task CommittedItemChangesAsync(Category category)
    {
        if (_addingCategory) await AddCategoryAsync(category);
        else await EditCategoryAsync(category);
    }

    private void CanceledEditingItem()
    {
        _addingCategory = false;
    }

    private async Task AddCategoryAsync(Category category)
    {
        if (_categories!.Select(x => x.Name).Contains(category.Name))
        {
            Snackbar.Add($"'{category.Name}' is already used as a Category name.", Severity.Warning);
            return;
        }
            
        _addingCategory = false;

        category.Color = _currentColor?.Value[..7] ?? "#f4c2c2";
            
        _categories!.Add(category);
        await CategoriesRepository.UpsertAsync(_categories);
    }

    private async Task EditCategoryAsync(Category category)
    {
        category.Color = _currentColor?.Value[..7] ?? "#f4c2c2";
        
        var budgetsWithCategory = await BudgetsRepository.Query()
            .Where(budget => budget.Expenses.Any(expense => expense.Category.Id == category.Id))
            .ToListAsync();
        foreach (var budget in budgetsWithCategory)
        {
            foreach (var expense in budget.Expenses.Where(expense => expense.Category.Id == category.Id))
            {
                expense.Category = category;
            }
        }
    
        var fixedBudget = await FixedBudgetRepository.ReadAsync();
        if (fixedBudget.Expenses.Any(expense => expense.Category.Id == category.Id))
        {
            foreach (var expense in fixedBudget.Expenses.Where(expense => expense.Category.Id == category.Id))
            {
                expense.Category = category;
            }
        }

        await CategoriesRepository.UpsertAsync(_categories!);
        
        foreach (var budget in budgetsWithCategory)
            await BudgetsRepository.UpsertAsync(budget);
        
        await FixedBudgetRepository.UpsertAsync(fixedBudget);
        
        Snackbar.Add("Category updated!", Severity.Success);
    }

    private async Task DeleteCategoryAsync(Category? category)
    {
        if (category is null) return;
        
        var budgetsWithCategory = await BudgetsRepository.Query()
            .Where(budget => budget.Expenses.Any(expense => expense.Category.Id == category.Id))
            .ToEnumerableAsync();
        if (budgetsWithCategory.Any())
        {
            Snackbar.Add($"'{category.Name}' is used in some budgets.", Severity.Warning);
            return;
        }

        var fixedBudget = await FixedBudgetRepository.ReadAsync();
        if (fixedBudget.Expenses.Any(expense => expense.Category.Id == category.Id))
        {
            Snackbar.Add($"'{category.Name}' is used in the fixed budget.", Severity.Warning);
            return;
        }

        _categories!.Remove(category);
        await CategoriesRepository.UpsertAsync(_categories);
    }
}